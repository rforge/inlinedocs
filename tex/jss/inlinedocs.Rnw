%  -*- compile-command: "make" -*- 
\documentclass[article]{jss}
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SweaveOpts{keep.source=TRUE}
<<echo=FALSE>>=
options(prompt=">>>",continue=">>>")
@ 
%% almost as usual
\newcommand{\inlinedocs}{\pkg{inlinedocs}}
\newcommand{\filepath}[1]{\texttt{#1}}
\author{Toby Dylan Hocking\\INRIA Paris \And 
        Thomas Wutzler\\MPI for Biogeochemistry, Jena}
\title{Sustainable, extensible documentation generation using \inlinedocs}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Toby Dylan Hocking, Thomas Wutzler} %% comma-separated
\Plaintitle{Sustainable, extensible documentation generation using
  \inlinedocs} %% without formatting
%\Shorttitle{A Capitalized Title} %% a short title (if necessary)
\newcommand{\R}{\proglang{R}}
%% an abstract and keywords
\Abstract{The concept of structured, interwoven code and documentation
  has existed for many years, but existing systems that implement this
  for the \R\ programming language do not take advantage of
  information present in the code. This article presents 2
  contributions for documentation generation for the \R\ community. First, 
  we propose a new syntax for inline documentation of \R\ code within
  comments adjacent to the relevant code, which allows for highly
  readable and maintainable code and documentation. Second, we propose an extensible
  system for parsing these comments, which allows the syntax to be
  easily augmented.}

\Keywords{Rd, documentation, documentation generation, literate
  programming, \proglang{R}}

\Plainkeywords{Rd, documentation, documentation generation, literate
  programming, R} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Toby Dylan Hocking\\
  INRIA - Sierra project\\
  23, avenue d'Italie\\
  CS 81321 \\
  75214 Paris Cedex 13\\
  Telephone: +33/1 39 63 54 99\\
  E-mail: \email{Toby.Hocking@inria.fr}\\
  URL: \url{http://cbio.ensmp.fr/~thocking/}\\
  \\	
  Thomas Wutzler\\
  Max Planck Institute for Biogeochemistry\\
  Hans-Knöll-Strasse 10\\
  07745 Jena, Germany\\
  Telephone: +49/3641 576271\\
  E-mail: \email{twutz@bgc-jena.mpg.de}\\
  URL: \url{https://www.bgc-jena.mpg.de/bgc-mdi/index.php/Main/ThomasWutzler}
}

%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

\section{Introduction}

\subsection[Existing documentation generation systems for R]{Existing
  documentation generation systems for \R}

For automatic report generation, the mature Sweave \citep{sweave}
format allows integration of R code and results within \LaTeX\
documents \citep{latex}.

However, the goal of \inlinedocs\ is different. It aims for
integration of Rd documentation inside of R code files, for automatic
documentation generation using markup in R comments. For this purpose,
there are already several different approaches, which we discuss
below.

package.skeleton \citep{R}

roxygen

Rdoc

\subsection{Documentation using inline comments}

motivation via function arguments, etc.

The remainder of the article is organized as follows. In
\autoref{syntax}, we discuss the details of the \inlinedocs\ syntax
for writing documentation in R comments. In \autoref{extensible}, we
discuss the design and implementation of \inlinedocs, and detail how
the syntax can be extended. In \autoref{conclusions}, we conclude and
offer some ideas for future improvements.

\section[The inlinedocs syntax]{The \inlinedocs\ syntax for inline
  documentation}
\label{syntax}

Documentation of \R-objects (i.e. variables, functions, arguments,
list entries) are written inside special comments, that are directly adjacent
to the source code of the objects. Adjacent \inlinedocs-comments are

\begin{itemize}
\item \verb+##<<+ on the same line as the the \R-object
\item \verb+###+ on the lines directly following the \R-object
\item \verb+###+ on the line directly before the \R-object
\end{itemize}

Furthermore, \inlinedocs\ allows to put text of various documentation
sections anywhere in the function header or body of a function by using the
\verb+##SECTION<<+ notation.

The following subsections describe common usage of \inlinedocs-comments. 

\subsection{Documenting function signatures and return values}

The following examples demonstrates the basic documentation of a function.
<<>>=
foo <- function(
  ### Adding two arguments
  first           ##<< the first argument 
  ,second=0       ##<< the second argument with a multi-line description
    ## that is possibly better placed in the details section
){
  first + second 
  ### returns the sum of 
  ### first and second
}
@ 

The comments are placed within sections of the corresponding 
documentation:
\begin{itemize}
\item Comment following the line of \code{function} is the description
section.
\item For each argument an item is created in the arguments section.
\item Comments following a \code{return} statement or the last line of the body make up the
value section.
\end{itemize} 

Name, alias and title of the documentation are set to the function name. The
location of white spaces, brackets, default arguments and commas is quite flexible.

\subsection{Documenting descriptions, links, and references}
The comments of the following example are placed in the title, details, and
seealso sections respectively.
 
<<>>=
bar <- function(
  ### Demonstrating section comments
  ##title<< bar-Function
){
  ##details<<
  ## This comment will show up in the details section.
  b <- rep(1,10)
  for( i in 2:10 ){
    ##details<<
    ## The cumulative sum, here, is calculated by a loop.\cr
    ## Such comments can be placed anywhere in the code.
    b[i] <- b[i-1]+i
  }
  b
  ### vector of cumulative sume of 1:10
  ##seealso<< \code{\link{foo}}
}
@

The \verb+##SECTION<<+ notation can be used for all documentation
sections (references, source, note, author, seealso, title, keyword, \ldots)
except for the examples section, which is handled in a special manner as shown below.

\subsection{Documenting list entries}
The documentation of list entries is conveniently done using \inlinedocs\ as shown in the following example.

<<>>=
center <- function(
  ### Average of a sample
  x               ##<< numeric vector of samples
  ,method=c(      ##<< method for calulating the center 
    ##describe<<
    mean="mean"       ##<< arithmetic mean   
    ,median="median") ##<< median
    ##end<<
  ,...            ##<< further arguments passed to mean or median
){
  method <- match.arg(method)
  res <- switch(method,
    mean = mean(x,...),
    median = median(x,...),
    stop("center: unknown method."))
  ##value<< a list with elements
  list(method=method,     ##<< method of calculating the average
       center=res)        ##<< the calculated average
  ##end<<
}
@

The list entries wrapped by \verb+##describe<<+ and \verb+##end<<+ lines can
be documented in the same way as function arguments. This construct can be
nested. This means that a list entry can be a list itself, whose items are described by such 
a block. Note, that the components must have names. 

\subsection{Providing examples}
The following example demonstrates attaching example code 
to the \code{center} function by using the \code{ex}-attribute.
<<>>=
attr(center,"ex") <- function(){
  x <- runif(10)
  center(x)
  center(x,method="median")
}
@

Using this method in combination with the \code{structure} function
when defining functions avoids the repetition of the function name. 
Hence, this is the preferred method for defining examples.
<<>>=
add2 <- structure(function(x){
  x+2
},ex=function(){
  add2(11) == 13
})
@

The methods for documenting examples were motivated by the desire a) to
express examples in R code rather than in R comments, and b) to keep the
examples close to the object definition. When examples are in R code
rather than comments, they are more easily transferred to the R
interpreter, and thus are easier to debug, change. They are correctly treated by the syntax
highlighters of most editors. Furthermore, when examples are written close to the
object definition, it is easier to keep examples up to date and informative.

Another way to document examples for an \R\ object \code{OBJ} is to write a
separate examples file \filepath{pkgdir/\emph{exdir}/OBJ.R}. The contents of the file 
is then used as the examples section. 
 
\subsection{Documenting S4 classes}

\section[The inlinedocs system of extensible documentation
generators]{The \inlinedocs\ system of extensible documentation
  generators}
\label{extensible}

\subsection{Structure of a Parser Function}

\subsection{forall/forfun}

\subsection{documentation lists}

Another intermediate representation that we considered was the
\code{"Rd"} object, as described by \cite{new-r-help}. It is a nested
list of character strings and lists, which is similar to the
documentation list format of \inlinedocs. However, from the point of
view of a Parser Function programmer, the \code{"Rd"} object is too
cumbersome. Documentation lists allow rapid development of Parser
Functions which are straightforward to read and modify.

\subsection{package.skeleton.dx}

how to call.

how to alter the default parsers: pkgdir/R/.inlinedocs.R variable
parsers or \texttt{options("inlinedocs.parsers")}.

\section{Future work and conclusions}
\label{conclusions}

We currently have implemented unit tests for documentation lists. This
assures that Parser Functions work as described. We also have unit
tests which ensure that the generated Rd passes R CMD check without
errors or warnings. It would be nice to also have unit tests for the
content of the generated Rd. We could compare documentation lists with
the output of the \code{parse_Rd} function as described by
\cite{parseRd}. Furthermore, this could be used to convert a
documentation list into an equivalent representation as an \code{"Rd"}
object, and we could use the \code{print.Rd} function to write the Rd
files. This could eventually be preferable to the current system of
starting from the output \code{package.skeleton} and doing find and
replace.

\bibliography{refs}

\end{document}
