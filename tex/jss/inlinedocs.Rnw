%  -*- compile-command: "make" -*- 
\documentclass[article]{jss}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SweaveOpts{keep.source=TRUE}
%% almost as usual
\newcommand{\inlinedocs}{\pkg{inlinedocs}}
\newcommand{\Rdoc}{\pkg{Rdoc}}
\newcommand{\Roxygen}{\pkg{Roxygen}}
\newcommand{\filepath}[1]{\texttt{#1}}
\author{Toby Dylan Hocking\\INRIA Paris \And 
        Thomas Wutzler\\MPI-BGC Jena \And
        Keith Ponting\\Aurix Ltd., UK  \And
        Philippe Grosjean\\University of Mons, Belgium}
\title{Sustainable, extensible documentation generation using \inlinedocs}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Toby Dylan Hocking, Thomas Wutzler, Keith Ponting, Philippe Grosjean} %% comma-separated
\Plaintitle{Sustainable, extensible documentation generation using
  inlinedocs} %% without formatting
%\Shorttitle{A Capitalized Title} %% a short title (if necessary)
\newcommand{\R}{\proglang{R}}
%% an abstract and keywords
\Abstract{The concept of structured, interwoven code and documentation
  has existed for many years, but existing systems that implement this
  for the \R\ programming language do not tightly integrate with \R\
  code, leading to several drawbacks. This article attempts to address
  these issues and presents 2 contributions for documentation
  generation for the \R\ community. First, we propose a new syntax for
  inline documentation of \R\ code within comments adjacent to the
  relevant code, which allows for highly readable and maintainable
  code and documentation. Second, we propose an extensible system for
  parsing these comments, which allows the syntax to be easily
  augmented.}

\Keywords{\proglang{R}, Rd, documentation, documentation generation,
  literate programming}

\Plainkeywords{Rd, documentation, documentation generation, literate
  programming, R} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Toby Dylan Hocking\\
  INRIA - Sierra project for machine learning research\\
  23, avenue d'Italie\\
  CS 81321 \\
  75214 Paris Cedex 13\\
  Telephone: +33/1 39 63 54 99\\
  E-mail: \email{Toby.Hocking@inria.fr}\\
  URL: \url{http://cbio.ensmp.fr/~thocking/}\\
  \\	
  Thomas Wutzler\\
  Max Planck Institute for Biogeochemistry\\
  Hans-Kn\"oll-Strasse 10\\
  07745 Jena, Germany\\
  Telephone: +49/3641 576271\\
  E-mail: \email{twutz@bgc-jena.mpg.de}\\
  \\	
  Keith Ponting\\
  Aurix Ltd.\\
  Malvern Hills Science Park\\
  Geraldine Road\\
  Great Malvern\\
  Worcestershire, WR14 3SZ, UK\\
  E-mail: \email{k.ponting@aurix.com}\\
  \\
  Philippe Grosjean\\
  Numerical Ecology of Aquatic Systems\\
  University of Mons\\
  20 Place du Parc, 7000 Mons, Belgium\\
  E-mail: \email{Philippe.Grosjean@umons.ac.be}
}

%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
<<echo=FALSE>>=
.libPaths(c("~/lib64/R/library", .libPaths()))
library(inlinedocs)
options(prompt = ">>>", continue = ">>>")
#print(.libPaths())
@ 

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

\section{Introduction}

The standard way to distribute \R\ code is in a package along with Rd
files that document the code. There are several existing methods for
documenting a package by writing \R\ comments, which are later processed and
converted into standard Rd files.
%The new idea in
%\inlinedocs\ is to write examples using actual \R\ code and
%documentation in comments right next to the code. 
We first review
these efforts, emphasing the key issues that justify
the introduction of a new package like \inlinedocs.

\subsection[Existing documentation generation systems for R]{Existing
  documentation generation systems for \R}

%% PhG: the usual package.skeleton() is NOT a solution to mix code and
%% documentation because it does not use existing comments to fill Rd
%% files. I would be more comfortable to present it as the starting point
%% that is, the default R documentation tools...

% TDH 2011-03-14 This next paragraph is offtopic, perhaps delete if
% space is required?
For automatic report generation and literate programming, the mature
Sweave \citep{sweave} format
% , also included in the default installation of \R, 
allows
integration of \R\ code and results within \LaTeX\ documents
\citep{latex}. However, the goal of \inlinedocs\ is different. It aims
for integration of Rd documentation inside of \R\ code files, for
documentation generation using \R\ code and markup in \R\ comments.

The \code{package.skeleton()} function that ships with base \R\ is
intended to ease the generation of Rd files from \R\ code
\citep{R}. After specifying some input \R\ code files or objects to
use for the package, it produces some minimal documentation that must
be filled in using a text editor. Although \code{package.skeleton()}
is sufficient for creating small packages that are published once and
forgotten, it offers little help for continued maintenance of packages
for which Rd files are frequently updated.

The other existing approaches, \Rdoc\ and \Roxygen, attempt to address
this sustainability problem using Rd generation from comments
in \R\  code \citep{rdoc,roxygen}. The documentation is thus written
closer to the code it documents, which is easier to maintain. These
packages are a step toward seamless integration of code and
documentation, but they have three major drawbacks:

\begin{enumerate}
\item They only use comments to generate documentation, ignoring the
  information already defined in the code. This is particularly
  problematic for documenting function arguments, which requires the
  repetition of the argument names in the function definition and the
  documentation. This repetition is a possible source of disagreement
  between code and documentation if both are not simultaneously
  updated.
\item The documentation for an object appears in comments above its
  definition. These comment blocks can grow to be quite large, and
  thus they tend to be far away from the relevant code.
\item Examples are defined either in comments or in supplementary \R\ 
  code files. Examples in comments are not easy to test and debug with
  the \R\  interpreter, and supplementary \R\ code files reintroduce the
  separation of code and documentation that these tools are supposed
  to eliminate.
\end{enumerate}

\subsection{Documentation using inline comments}

The \inlinedocs\ package addresses the aforementioned issues by
proposing a new syntax for inline documentation of \R\ packages. Using
\inlinedocs, one writes documentation in comments right next to the
relevant code, and examples in the \code{ex} attribute of the relevant
object. The resulting code is free of duplication and very easy to
maintain.

The remainder of the article is organized as follows. In
\autoref{syntax}, we discuss the details of the \inlinedocs\ syntax
for writing documentation in \R\  comments. In \autoref{extensible}, we
discuss the design and implementation of \inlinedocs, and explain how
the syntax can be extended. In \autoref{conclusions}, we conclude and
offer some ideas for future improvements.

\newpage
\section[The inlinedocs syntax for inline documentation of R packages]{The
  \inlinedocs\ syntax for inline
  documentation of \R\ packages}
\label{syntax}

The main idea of \inlinedocs\ is to document an \R\ object using
\verb+###+ and \verb+##<<+ comments directly adjacent to its source
code. Furthermore, \inlinedocs\ allows documentation
wherever it is most relevant in the code using \verb+##section<<+
comments.
These special comment strings are designed to work well with
the default behavior of common editors, such as Emacs Speaks
Statistics \citep{ESS}:  
\begin{itemize}
\item \verb+###+ is automatically aligned to the left margin,
  providing maximum space for comment text.
\item \verb+##<<+ is aligned with the start of adjacent code lines, so
  that comments using this form in the middle of a function do not
  obscure the code structure.
\end{itemize}

The following subsections illustrate common usage of \inlinedocs\
comments through \pkg{fermat}, an example package inspired by the
\Roxygen\ vignette \citep{roxygen}. For brevity, only the most
frequently used \inlinedocs\ features will be discussed, and the
reader is directed to the \inlinedocs\ web site for complete
documentation:

\url{http://inlinedocs.r-forge.r-project.org/}

\subsection{Documenting function signatures and return values}

The following example demonstrates the minimal documentation a package author
should provide for every function. Note that the location of white
space, brackets, default arguments and commas is quite flexible.
<<>>=
fermat.test <- function
### Test an integer for primality using Fermat's Little Theorem.
(n ##<< The integer to test.
 ){
  a <- floor(runif(1,min=1,max=n))
  a^n %% n == a
### Whether the integer passes the Fermat test for a randomized
### \eqn{0<a<n}.
}
@ 

The comments are placed within sections of the corresponding 
Rd file:
\begin{itemize}
\item \verb+###+ comments following the line of \code{function}
  form the \code{description} section.
\item For each argument, an item is created in the \code{arguments}
  section using a \verb+##<<+ comment on the same line.
\item \verb+###+ comments on the last line of the function form the
  \code{value} section.
\end{itemize} 

By default, \code{name}, \code{alias} and \code{title} Rd sections are
set to the function name, so this minimal level of documentation
is enough to make a working package that passes \code{R CMD
  check} with no errors or warnings.

\newpage
\subsection{Inline titles, arguments, and other sections}

The following example shows some optional \inlinedocs\ comments that
allow detailed and flexible specification of Rd files.
 
<<>>=
is.pseudoprime <- function # Check an integer for pseudo-primality.
### A number is pseudo-prime if it is probably prime, the basis of
### which is the probabalistic Fermat test; if it passes two such
### tests, the chances are better than 3 out of 4 that \eqn{n} is
### prime.
##references<< Abelson, Hal; Jerry Sussman, and Julie
##Sussman. Structure and Interpretation of Computer
##Programs. Cambridge: MIT Press, 1984.
(n,    ##<< Integer to test for pseudoprimality.
 times
### Number of Fermat tests to perform. More tests are more likely to
### give accurate results.
 ){
  if(times==0)TRUE
  ##seealso<< \code{\link{fermat.test}}
  else if(fermat.test(n)) is.pseudoprime(n,times-1)
  else FALSE
### logical TRUE if n is probably prime.
}
@

On the first line, the \verb+#+ comment specifies the title.  On the
lines after an argument, \verb+###+ comments specify its
documentation. This is a useful alternative to inline \verb+##<<+
comments for longer, multi-line documentation.

A \verb+##section<<+ comment can be used anywhere within a function,
for any documentation section except \code{examples}, which is
handled in a special manner as shown below in
section~\ref{sec:exattr}. In each comment, arbitrary Rd may be
written, as shown in the \verb+##seealso<<+ section above.  Each
\verb+##section<<+ may occur several times in a single documentation
object. Each occurrence is normally concatenated as separate
paragraphs, but special processing is applied to match the intended
use of the following documentation sections:
\begin{itemize}
\item \texttt{title} sections are concatenated into a single line.
\item \texttt{description} sections should be brief, so are concatenated into a
  single paragraph.
\item \texttt{alias} contents are split to give one alias per line of text.
\item \texttt{keyword} contents are split at white space, each generating a
  separate \verb+\keyword+ entry.
\end{itemize}

The \verb+###+ and \verb+##<<+ documentation styles may be freely
mixed. In general, \verb+###+ or \verb+#+ lines are processed first,
followed by any corresponding \verb+##<<+ or \verb+##section<<+
comments. Section \ref{extensible} will explain in more detail how
comments are processed.

\newpage
\subsection{Examples and named lists}

The following code demonstrates inline documentation of named lists,
and the preferred method of writing examples:
<<>>=
try.several.times <- structure(function
### Test an integer for primality using different numbers of tests.
(n,    ##<< integer to test for primality.
 times ##<< vector of number of tests to try.
 ){
  is.prime <- sapply(times,function(t)is.pseudoprime(n,t))
  ##value<< data.frame with columns:
  data.frame(times, ##<< number of Fermat tests.
             is.prime, ##<< TRUE if probably prime
             n) ##<< Integer tested.
  ##end<<
},ex=function(){
  try.several.times(6,1:5)
  try.several.times(5,1:5)
})
@ 

On the final lines of the function definition, a \verb+##value<<+
comment allows documentation of lists or data frames using the names
defined in the code. The entries are documented using \verb+##<<+ in
the same way as function arguments, and this even works for nested
lists.

\label{sec:exattr}

The examples are written using \code{structure()} to put them in the
\code{ex} attribute as the body of a function without arguments. This
method for documenting examples was motivated by the desire to express
examples in \R\ code rather than in \R\ comments, and to keep the
examples close to the object definition. When examples are in \R\
code, they are easily transferred to the \R\ interpreter, and thus are
easy to debug. Furthermore, when examples are written close to the
object definition, it is easy to keep examples up to date and
informative.

The simplicity of adding examples and generating a package using
\inlinedocs\ also allows for routine regression testing of functions
with very little extra work. Even for small collections of functions,
one can use \verb+R CMD check+ to run the examples and optionally
check the output with reference output.

% Since
% moving to inlinedocs I find that whether or not I have a package in
% mind, any function longer than a few lines tends to get inlinedocs
% comments as I write it or soon after. The thought process tends to go:
% This is a useful sequence of operations - make it a function - test it -
% any possibility of reuse? - add comments if they are not already there -
% think about regression testing/example input and output. 

\newpage
\subsection{Documenting classes and methods}

The \inlinedocs\ package automatically detects which functions are S3
methods, whether defined in plain \R, or using \verb+setConstructorS3+
and \verb+setMethodS3+ from the \pkg{R.oo} package \citep{Roo}. S4
class declarations using the \verb+setClass+ function are also
supported, but S4 generic methods are not yet supported. The following
example is from the source of \inlinedocs:
<<term=FALSE>>=
setClass("DocLink", # Link documentation among related functions
### The \code{DocLink} class provides the basis for hooking together
### documentation of related classes/functions/objects. The aim is that
### documentation sections missing from the child are inherited from
### the parent class.
    representation(name = "character", ##<< name of object
                   created = "character", ##<< how created
                   parent = "character", ##<< parent class or NA
                   code = "character", ##<< actual source lines
                   description = "character") ##<< preceding description block
         )
@ 

The inheritance referred to in this example is designed to avoid the
need for repetitive documentation when defining a class hierarchy. The
argument descriptions and other documentation sections default to
those defined in the parent class. At present it only functions when
all the definitions are within a single source file and this
``documentation inheritance'' is strictly linear within the file.

\subsection[package.skeleton.dx for generating Rd files]
{\code{package.skeleton.dx()} for generating Rd files}

The main function that the \inlinedocs\ package provides is
\code{package.skeleton.dx("fermat")}, which processes R code found in
\code{fermat/R}, and generates Rd files in \code{fermat/man}. This
operates first by running \code{package.skeleton()} to generate blank
Rd files, which are updated using the inline documentation specified
in the \R\ code. After running \code{package.skeleton.dx()}, the
package documentation will be up to date with the code, and the
package should pass \code{R CMD check} without errors or warnings.

\newpage
\section[The inlinedocs system of extensible documentation
generators]{The \inlinedocs\ system of extensible documentation
  generators}
\label{extensible}

The previous section explains how to write inline documentation
in \R\  code using the standard \inlinedocs\ syntax, then process it to
generate Rd files using \code{package.skeleton.dx()}. For most users of
\inlinedocs\ this should be sufficient for everyday use.

For users who wish to extend the syntax of \inlinedocs, here we
explain the internal organization of the \inlinedocs\ package. The two
central concepts are Parser Functions and Documentation Lists. Parser
Functions are used to extract documentation from \R\ code, which is
then stored in a Documentation List before writing Rd files.

\subsection{Documentation Lists store the structured content of Rd files}

A Documentation List is a list of lists that describes all of the
documentation to write to the Rd files. The elements of the outer list
correspond to Rd files in the package, and the elements of the inner
list correspond to tags in an Rd file. For example, consider the
following code and its corresponding Documentation List.

\begin{small}
\begin{minipage}{0.4\textwidth}
  R code\hrulefill
<<echo=FALSE>>=
cat(paste(readLines("doclist.R"), collapse = "\n")) 
@ 
\end{minipage}
\begin{minipage}{0.45\textwidth}
  Documentation List\hrulefill
<<echo=FALSE,result=TRUE>>=
dl <- extract.docs.file("doclist.R")
show <- lapply(dl, function (L) L[!names(L) %in% c("definition", "format")])
str(show)
@
\end{minipage}
\end{small}

\hrulefill

Parser Functions examine the lines of code on the left that define the
functions, and return the Documentation List of tags shown on the
right. This list describes the tags in the Rd files that will be
written for these functions. The names of the outer list specify the
Rd file, and the names of the inner list specify the Rd tag.

To store parsed documentation, another intermediate representation
that we considered instead of the Documentation List was the
\code{"Rd"} object, as described by \cite{new-r-help}. It is a
recursive structure of lists and character strings, which is similar
to the Documentation List format of \inlinedocs. However, from the
point of view of a Parser Function programmer, creating all the
attrbute tags to make a valid \code{"Rd"} object is too
cumbersome. Documentation lists allow rapid development of Parser
Functions which are straightforward to read, write, and modify.

\subsection[Structure of a Parser Function and forall/forfun]{Structure of a
  Parser Function and \code{forall()}/\code{forfun()}}

The job of a Parser Function is to return a Documentation List for a
package. To do this, it will require knowledge of what is defined in
the package, so the following arguments are supplied by \inlinedocs:
\begin{center}
\begin{tabular}{ll}
  Argument & Description \\
  \hline
  \code{code} & Character vector of all lines of \R\  code in the package.\\
  \code{env} & Environment in which the lines of code are evaluated.\\
  \code{objs} & List of all \R\  objects defined in the package.\\
  \code{docs} & Documentation List from previous Parser Functions.\\
  \code{desc} & 1-row matrix
  of DESCRIPTION metadata, as read by \code{read.dcf()}.
\end{tabular}
\end{center}

The \R\  code files in the package are concatenated into \code{code} and
then parsed into \code{objs}, and the DESCRIPTION metadata is
available as \code{desc}. These arguments allow complete flexibility
in the construction of Parser Functions that take apart the package
and extract meaningful Documentation Lists. In addition, the
\code{docs} argument allows for checking of what previous Parser
Functions have already extracted.

In principle, one could write a single monolithic Parser Function that
extracts all tags for all Rd files for the package, then returns the
entire Documentation List. However, in practice, this results in one
unwieldly Parser Function that does many things and is hard to
maintain. A simpler strategy is to write several smaller Parser
Functions, each of which produces an inner Documentation List for a
specific Rd file, such as the following:

<<>>=
title.from.firstline <- function (src, ...) {
  first <- src[1]
  if (grepl("#", first)) {
    list(title = gsub("[^#]*#\\s*(.*)", "\\1", first, perl = TRUE))
  } else list()
}
@

This function takes \code{src}, a character vector of \R\ code lines
that define a function, and looks for a comment on the first line. If
there is a comment, \code{title.from.firstline()} returns the comment
as the title in an inner Documentation List. This a very simple and
readable way to define a Parser Function.

But how does this Parser Function get access to the \code{src} argument
for an individual function? We introduce the \code{forall()} and
\code{forfun()} functions, which transform an object-specific Parser
Function such as \code{title.from.firstline} to a Parser Function that
can work on an entire package. These functions examine the \code{objs}
and \code{docs} arguments, and call the object-specific Parser Function
on each object in turn. The \code{forfun()} function applies to every
function in the package, whereas the \code{forall()} function applies to
every documentation object in the package.

Thus, when using a Parser Function such as
\code{forfun(title.from.firstline)}, the following
arguments can be used in the definition of \code{title.from.firstline}, in
addition to those discussed above that are passed to every Parser
Function:
\begin{center}
\begin{tabular}{ll}
  Argument & Description \\
  \hline
  \code{o} & The \R\  object.\\
  \code{name} & The name of the object.\\
  \code{src} & The \code{"source"} attribute of the object.\\
  \code{doc} & The inner Documentation List
  already constructed for this object.
\end{tabular}
\end{center}

The \code{parsers} argument to \code{package.skeleton.dx()} allows
control of the list of Parser Functions used to create the
Documentation List for the package. The Parser Functions will be
called in sequence, and their results will be combined to form the
final Documentation List that will be used to write Rd files.

This design choice of \inlinedocs\ allows the development of modular
Parser Functions. For example, there is one Parser Function for
\verb+###+ comments, another for \verb+##<<+ comments, another for
adding the \code{author} tag using the Maintainer line of the
DESCRIPTION file, etc. Each of these Parser Functions is relatively
small and thus easy to maintain.

Furthermore, this design choice allows the
\inlinedocs\ syntax the be extended by simply writing a new Parser
Function. Currently, there are no extensions that take advantage of
this feature of \inlinedocs, but it serves to streamline development of
the internal \inlinedocs\ Parser Functions.

\section{Conclusions and future work}
\label{conclusions}

We have presented \inlinedocs, which is both a new syntax for inline
documentation of \R\ packages, and an extensible system for parsing
this syntax and generating Rd files. It has been in development since
2009 on R-Forge \citep{rforge}, has seen several releases on CRAN, and
has been used to generate documentation for itself and several other
\R\ packages. In practice, we have found that \inlinedocs\
significantly reduces the amount of time it takes to create a package
that passes \texttt{R CMD check}. In addition, \inlinedocs\
facilitates rapid package updates since the documentation is written
in comments right next to the relevant code.

For quality assurance, we currently have implemented unit tests for
Documentation Lists, which assure that Parser Functions work as
described. We also have unit tests which ensure that the generated Rd
passes \code{R CMD check} without errors or warnings.

Currently, the \inlinedocs\ package relies on the \code{source}
attribute of a function to access its documentation, but that
mechanism does not work for S4 methods. Instead, we currently
use \code{parse()} on the source files to access S4 class definitions,
and we
% (via \verb+setClass+) and S3 class and method definitions using the
% \verb+R.oo+ \verb+setConstructorS3+ and \verb+setMethodS3+
% approach);
intend to extend that in order to be able to generate documentation
for S4 methods and reference classes.
%(as well as the new \verb+setRefClass+ and \verb+$methods+ route
%for attaching methods to such classes)
% There is a further uncertainty whether to document the \verb+myFun+
% method for \verb+myClass+ in \verb+myClass-class.Rd+ or
% \verb+myFun-methods.Rd+. The standard \verb+package.skeleton+ places
% the appropriate alias in both locations, but to avoid
% warnings from \verb+R CMD check+ the author must delete one. A
% possible heuristic would be to say that if there is one definition for
% \verb+myFun+ then the documentation goes into \verb+myClass-class.Rd+,
% otherwise into \verb+myFun-methods.Rd+.

For the future, we would like to make use of Rd manipulation tools
such as \code{parse_Rd()}, as described by \cite{parseRd}. In
particular, it would be advantageous to have functions for converting
Documentation Lists to and from \code{"Rd"} objects. For example,
after converting an inner Documentation List to an \code{"Rd"} object,
we could use the \code{print.Rd()} function to write the Rd file. This
could be simpler than the current system of starting from the Rd files
from \code{package.skeleton()} and then doing find and
replace. Furthermore, a converter from \code{"Rd"} objects to
Documentation Lists would permit unit tests for the content of the Rd
generated by \inlinedocs.

\newpage
\bibliography{refs}

\end{document}
