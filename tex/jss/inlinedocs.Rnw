%  -*- compile-command: "make" -*- 
\documentclass[article]{jss}
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SweaveOpts{keep.source=TRUE}
%% almost as usual
\newcommand{\inlinedocs}{\pkg{inlinedocs}}
\newcommand{\filepath}[1]{\texttt{#1}}
\author{Toby Dylan Hocking\\INRIA Paris \And 
        Thomas Wutzler\\MPI for Biogeochemistry, Jena}
\title{Sustainable, extensible documentation generation using \inlinedocs}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Toby Dylan Hocking, Thomas Wutzler} %% comma-separated
\Plaintitle{Sustainable, extensible documentation generation using
  \inlinedocs} %% without formatting
%\Shorttitle{A Capitalized Title} %% a short title (if necessary)
\newcommand{\R}{\proglang{R}}
%% an abstract and keywords
\Abstract{The concept of structured, interwoven code and documentation
  has existed for many years, but existing systems that implement this
  for the \R\ programming language do not take advantage of
  information present in the code. This article presents 2
  contributions for documentation generation for the \R\ community. First, 
  we propose a new syntax for inline documentation of \R\ code within
  comments adjacent to the relevant code, which allows for highly
  readable and maintainable code and documentation. Second, we propose an extensible
  system for parsing these comments, which allows the syntax to be
  easily augmented.}

\Keywords{Rd, documentation, documentation generation, literate
  programming, \proglang{R}}

\Plainkeywords{Rd, documentation, documentation generation, literate
  programming, R} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Toby Dylan Hocking\\
  INRIA - Sierra project\\
  23, avenue d'Italie\\
  CS 81321 \\
  75214 Paris Cedex 13\\
  Telephone: +33/1 39 63 54 99\\
  E-mail: \email{Toby.Hocking@inria.fr}\\
  URL: \url{http://cbio.ensmp.fr/~thocking/}\\
  \\	
  Thomas Wutzler\\
  Max Planck Institute for Biogeochemistry\\
  Hans-Knöll-Strasse 10\\
  07745 Jena, Germany\\
  Telephone: +49/3641 576271\\
  E-mail: \email{twutz@bgc-jena.mpg.de}\\
  URL: \url{https://www.bgc-jena.mpg.de/bgc-mdi/index.php/Main/ThomasWutzler}
}

%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
<<echo=FALSE>>=
.libPaths(c("~/lib64/R/library",.libPaths()))
library(inlinedocs)
options(prompt=">>>",continue=">>>")
#print(.libPaths())
@ 

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

\section{Introduction}

\subsection[Existing documentation generation systems for R]{Existing
  documentation generation systems for \R}

For automatic report generation, the mature Sweave \citep{sweave}
format allows integration of R code and results within \LaTeX\
documents \citep{latex}.

However, the goal of \inlinedocs\ is different. It aims for
integration of Rd documentation inside of R code files, for automatic
documentation generation using markup in R comments. For this purpose,
there are already several different approaches, which we discuss
below.

package.skeleton \citep{R}

roxygen

Rdoc

\subsection{Documentation using inline comments}

motivation via function arguments, etc.

The remainder of the article is organized as follows. In
\autoref{syntax}, we discuss the details of the \inlinedocs\ syntax
for writing documentation in R comments. In \autoref{extensible}, we
discuss the design and implementation of \inlinedocs, and detail how
the syntax can be extended. In \autoref{conclusions}, we conclude and
offer some ideas for future improvements.

\section[The inlinedocs syntax]{The \inlinedocs\ syntax for inline
  documentation}
\label{syntax}

Documentation of \R-objects (i.e. variables, functions, arguments,
list entries) are written inside special comments, that are directly adjacent
to the source code of the objects. Adjacent \inlinedocs-comments are

\begin{itemize}
\item \verb+##<<+ on the same line as the the \R-object
\item \verb+###+ on the lines directly following the \R-object
\item \verb+###+ on the line directly before the \R-object
\end{itemize}

Furthermore, \inlinedocs\ allows to put text of various documentation
sections anywhere in the function header or body of a function by using the
\verb+##SECTION<<+ notation.

The following subsections describe common usage of \inlinedocs-comments. 

\subsection{Documenting function signatures and return values}

The following examples demonstrates the basic documentation of a function.
<<>>=
foo <- function(
  ### Adding two arguments
  first           ##<< the first argument 
  ,second=0       ##<< the second argument with a multi-line description
    ## that is possibly better placed in the details section
){
  first + second 
  ### returns the sum of 
  ### first and second
}
@ 

The comments are placed within sections of the corresponding 
documentation:
\begin{itemize}
\item Comment following the line of \code{function} is the description
section.
\item For each argument an item is created in the arguments section.
\item Comments following a \code{return} statement or the last line of the body make up the
value section.
\end{itemize} 

Name, alias and title of the documentation are set to the function name. The
location of white spaces, brackets, default arguments and commas is quite flexible.

\subsection{Documenting descriptions, links, and references}
The comments of the following example are placed in the title, details, and
seealso sections respectively.
 
<<>>=
bar <- function(
  ### Demonstrating section comments
  ##title<< bar-Function
){
  ##details<<
  ## This comment will show up in the details section.
  b <- rep(1,10)
  for( i in 2:10 ){
    ##details<<
    ## The cumulative sum, here, is calculated by a loop.\cr
    ## Such comments can be placed anywhere in the code.
    b[i] <- b[i-1]+i
  }
  b
  ### vector of cumulative sume of 1:10
  ##seealso<< \code{\link{foo}}
}
@

The \verb+##SECTION<<+ notation can be used for all documentation
sections (references, source, note, author, seealso, title, keyword, \ldots)
except for the examples section, which is handled in a special manner as shown below.

\subsection{Documenting list entries}
The documentation of list entries is conveniently done using \inlinedocs\ as shown in the following example.

<<>>=
center <- function(
  ### Average of a sample
  x               ##<< numeric vector of samples
  ,method=c(      ##<< method for calulating the center 
    ##describe<<
    mean="mean"       ##<< arithmetic mean   
    ,median="median") ##<< median
    ##end<<
  ,...            ##<< further arguments passed to mean or median
){
  method <- match.arg(method)
  res <- switch(method,
    mean = mean(x,...),
    median = median(x,...),
    stop("center: unknown method."))
  ##value<< a list with elements
  list(method=method,     ##<< method of calculating the average
       center=res)        ##<< the calculated average
  ##end<<
}
@

The list entries wrapped by \verb+##describe<<+ and \verb+##end<<+
lines can be documented in the same way as function arguments. This
construct can be nested. This means that a list entry can be a list
itself, whose items are described by such a block. Note that the
components of the list must have names.

\subsection{Providing examples}
The following example demonstrates attaching example code 
to the \code{center} function by using the \code{ex}-attribute.
<<>>=
attr(center,"ex") <- function(){
  x <- runif(10)
  center(x)
  center(x,method="median")
}
@

Using this method in combination with the \code{structure} function
when defining functions avoids the repetition of the function name. 
Hence, this is the preferred method for defining examples.
<<>>=
add2 <- structure(function(x){
  x+2
},ex=function(){
  add2(11) == 13
})
@

The methods for documenting examples were motivated by the desire to
express examples in R code rather than in R comments, and to keep the
examples close to the object definition. When examples are in R code
rather than comments, they are more easily transferred to the R
interpreter, and thus are easier to debug. Furthermore, when examples
are written close to the object definition, it is easier to keep
examples up to date and informative.

\subsection{Documenting S4 classes}

\subsection[package.skeleton.dx for generating Rd files]{\code{package.skeleton.dx} for generating Rd files}

The main function that the \inlinedocs\ package provides is
\code{package.skeleton.dx("pkgdir")}, which generates Rd
files in \code{pkgdir/man}. This operates first by running
\code{package.skeleton} to generate blank Rd files, which are updated
using the inline documentation specified in the R code. After running
\code{package.skeleton.dx}, the package documentation will be up to
date with the code, and the package should pass R CMD check without
errors or warnings.

\section[The inlinedocs system of extensible documentation
generators]{The \inlinedocs\ system of extensible documentation
  generators}
\label{extensible}

The previous section has explained how to write inline documentation
in R code using the standard \inlinedocs\ syntax, then process it to
generate Rd files using \code{package.skeleton.dx}. For most users of
\inlinedocs\ this should be sufficient for everyday use.

For users who wish to extend the syntax of \inlinedocs, the following
sections explain the internal organization of the \inlinedocs\
package. The 2 central concepts are Parser Functions and Documentation
Lists. Parser Functions are used to extract documentation from R code,
which is then stored in a Documentation List before writing Rd files,
as explained in the following sections.

\subsection{Documentation Lists store the structured content of Rd files}

A Documentation List is a list of lists that describes all of the
documentation to write to the Rd files. The elements of the outer list
correspond to Rd files in the package, and the elements of the inner
list correspond to tags in an Rd file. For example, consider the
following code chunk and its corresponding Documentation List.

\begin{small}
\begin{minipage}{0.4\textwidth}
  R code\hrulefill
<<echo=FALSE>>=
cat(paste(readLines("doclist.R"),collapse="\n")) 
@ 
\end{minipage}
\begin{minipage}{0.45\textwidth}
  Documentation List\hrulefill
<<echo=FALSE,result=TRUE>>=
dl <- extract.docs.file("doclist.R")
show <- lapply(dl,function(L)L[!names(L)%in%c("definition","format")])
str(show)
@
\end{minipage}
\end{small}

\hrulefill

Parser Functions examine the lines of code that define the functions,
and return the Documentation List of tags shown on the right. This
list describes the tags in the Rd file that will be written for these
functions. The names of the outer list specify the Rd file, and the
names of the inner list specify the Rd tag.

To store parsed documentation, another intermediate representation
that we considered instead of the Documentation List was the
\code{"Rd"} object, as described by \cite{new-r-help}. It is a nested
list of character strings and lists, which is similar to the
Documentation List format of \inlinedocs. However, from the point of
view of a Parser Function programmer, creating all the attrbute tags
to make a valid \code{"Rd"} object is too cumbersome. Documentation
lists allow rapid development of Parser Functions which are
straightforward to read, write, and modify. 

\subsection[Structure of a Parser Function and forall/forfun]{Structure of a
  Parser Function and \code{forall}/\code{forfun}}

The job of a Parser Function is to return a Documentation List for a
package. To do this, it will require knowledge of what is defined in
the package, so the following arguments are supplied by \inlinedocs:
\begin{center}
\begin{tabular}{cl}
  Argument & Description \\
  \hline
  \code{code} & Character vector of all lines of R code in the package.\\
  \code{objs} & List of all R objects defined in the package.\\
  \code{docs} & Documentation List from previous Parser Functions.\\
  \code{desc} & 1-row matrix
  of DESCRIPTION metadata, as read by \code{read.dcf}.
\end{tabular}
\end{center}

The R code files in the package are concatenated into \code{code} and
then parsed into \code{objs}, and the DESCRIPTION metadata is
available as \code{desc}. These arguments allow complete flexibility
in the construction of Parser Functions that take apart the package
and extract meaningful Documentation Lists. In addition, the
\code{docs} argument allows for checking of what previous Parser
Functions have already extracted.

In principle, one could write a single monolithic Parser Function that
extracts all tags for all Rd files for the package, then returns the
entire Documentation List. However, in practice, this results in one
unwieldly Parser Function that does many things and is hard to
maintain. A simpler strategy is to write several smaller Parser
Functions, each of which produces an inner Documentation List for a
specific Rd file, such as the following:

<<>>=
title.from.firstline <- function(src,...){
  if(grepl("#",first)){
    list(title=gsub("[^#]*#\\s*(.*)","\\1",first,perl=TRUE))
  }else list()
}
@

This function takes \code{src}, the R code that defines a function,
and looks for a comment on the first line. If there is a comment,
\code{title.from.firstline} returns the comment as the title in an
inner Documentation List. It would be nice to have a sensible default
title even if it is not specified as a comment on the first line, so
we can use another Parser Function such as the following:

<<>>=
title.from.name <- function(name,doc,...){
  if("title"%in%names(doc))list() else
  list(title=gsub("[._]"," ",name))
}
@ 

This function takes the name of a function \code{name}, and the
documentation already extracted for it \code{doc}. If no title has
been specified by previous Parser Functions such as
\code{title.from.firstline}, it returns an inner Documentation List
with a title based on the object name.

But how do these Parser Functions get access to the \code{src},
\code{name}, and \code{doc} arguments for individual documentation
objects?  To implement this strategy, we introduce the \code{forall}
and \code{forfun} functions, which transform an object-specific Parser
Function such as \code{title.from.name} to a Parser Function that can
work on an entire package. These functions examine the \code{objs} and
\code{docs} arguments, and call the object-specfic Parser Function on
each object in turn. The \code{forfun} function applies to every
function in the package, whereas the \code{forall} function applies to
every documentation object in the package.

Thus, when using a Parser Function such as
\code{forfun(title.from.name)}, you can use the following arguments in
the definition of \code{title.from.name}, in addition to those
discussed above that are passed to every Parser Function:
\begin{center}
\begin{tabular}{ll}
  Argument & Description \\
  \hline
  \code{o} & The R object.\\
  \code{name} & The name of the object.\\
  \code{doc} & The inner Documentation List
  already constructed for this object.\\
  \code{src} & The \code{"source"} attribute of the object.\\
\end{tabular}
\end{center}

The \code{parsers} argument to \code{package.skeleton.dx} allows
control of the list of Parser Functions used to create the
Documentation List for the package. They will be called in sequence,
and their results will be combined to form the final Documentation
List that will be used to write Rd files. This design choice of
\inlinedocs\ allows the development of modular Parser functions. For
example, there is one Parser Function for \verb+###+ comments, another
for \verb+##<<+ comments, another for adding the author tag using the
Maintainer line of the DESCRIPTION file, etc.

Furthermore, this design choice also allows easy extensions to the
\inlinedocs\ syntax by simply writing a few new Parser
Functions. Currently, there are no extensions that take advantage of
this feature of inlinedocs, but it serves to streamline development of
the internal \inlinedocs\ Parser Functions.

\section{Conclusions and future work}
\label{conclusions}

We have presented \inlinedocs, which is both a new syntax for inline
documentation of \R\ packages, and an extensible system for parsing this
syntax and generating the Rd files. It has been in development since
2009 on R-Forge \citep{rforge}, has seen several releases on CRAN, and
is now considered stable.

For quality assurance, we currently have implemented unit tests for
Documentation Lists, which assure that Parser Functions work as
described. We also have unit tests which ensure that the generated Rd
passes R CMD check without errors or warnings.

For the future, it would be nice to also have unit tests for the
content of the generated Rd. We could compare Documentation Lists with
the output of the \code{parse_Rd} function as described by
\cite{parseRd}. Furthermore, this could be used to convert a
Documentation List into an equivalent representation as an \code{"Rd"}
object, and we could use the \code{print.Rd} function to write the Rd
files. This could eventually be used instead of the current system of
starting from the output of \code{package.skeleton} and doing find and
replace.

\bibliography{refs}

\end{document}
