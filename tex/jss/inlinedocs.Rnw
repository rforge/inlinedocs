%  -*- compile-command: "make" -*- 
\documentclass[article]{jss}
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\SweaveOpts{keep.source=TRUE}
%% almost as usual
\newcommand{\inlinedocs}{\pkg{inlinedocs}}
\newcommand{\Rdoc}{\pkg{Rdoc}}
\newcommand{\Roxygen}{\pkg{Roxygen}}
\newcommand{\filepath}[1]{\texttt{#1}}
\author{Toby Dylan Hocking\\INRIA Paris \And 
        Thomas Wutzler\\MPI for Biogeochemistry, Jena \And
        Keith Ponting\\Aurix Ltd., UK  \And
        Philippe Grosjean\\University of Mons, Belgium}
\title{Sustainable, extensible documentation generation using \inlinedocs}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Toby Dylan Hocking, Thomas Wutzler, Keith Ponting, Philippe Grosjean} %% comma-separated
\Plaintitle{Sustainable, extensible documentation generation using
  inlinedocs} %% without formatting
%\Shorttitle{A Capitalized Title} %% a short title (if necessary)
\newcommand{\R}{\proglang{R}}
%% an abstract and keywords
\Abstract{The concept of structured, interwoven code and documentation
  has existed for many years, but existing systems that implement this
  for the \R\ programming language do not tightly integrate with \R\
  code, leading to several drawbacks. This article attempts to address
  these issues and presents 2 contributions for documentation
  generation for the \R\ community. First, we propose a new syntax for
  inline documentation of \R\ code within comments adjacent to the
  relevant code, which allows for highly readable and maintainable
  code and documentation. Second, we propose an extensible system for
  parsing these comments, which allows the syntax to be easily
  augmented.}

\Keywords{\proglang{R}, Rd, documentation, documentation generation,
  literate programming}

\Plainkeywords{Rd, documentation, documentation generation, literate
  programming, R} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Toby Dylan Hocking\\
  INRIA - Sierra project for machine learning research\\
  23, avenue d'Italie\\
  CS 81321 \\
  75214 Paris Cedex 13\\
  Telephone: +33/1 39 63 54 99\\
  E-mail: \email{Toby.Hocking@inria.fr}\\
  URL: \url{http://cbio.ensmp.fr/~thocking/}\\
  \\	
  Thomas Wutzler\\
  Max Planck Institute for Biogeochemistry\\
  Hans-Kn\"oll-Strasse 10\\
  07745 Jena, Germany\\
  Telephone: +49/3641 576271\\
  E-mail: \email{twutz@bgc-jena.mpg.de}\\
  \\	
  Keith Ponting\\
  Aurix Ltd.\\
  Malvern Hills Science Park\\
  Geraldine Road\\
  Great Malvern\\
  Worcestershire, WR14 3SZ, UK\\
  E-mail: \email{k.ponting@aurix.com}\\
  \\
  Philippe Grosjean\\
  Numerical Ecology of Aquatic Systems\\
  University of Mons\\
  20 Place du Parc, 7000 Mons, Belgium\\
  E-mail: \email{Philippe.Grosjean@umons.ac.be}
}

%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
<<echo=FALSE>>=
.libPaths(c("~/lib64/R/library", .libPaths()))
library(inlinedocs)
options(prompt = ">>>", continue = ">>>")
#print(.libPaths())
@ 

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

\section{Introduction}

The \inlinedocs\ package introduces the concept of documenting a
package using inline code and comments to the \R\ programming
language. There are several existing packages that attempt to address
this. We first review these alternate implementations, emphasing the
key issues that justify the introduction of a new package like
\inlinedocs.

\subsection[Existing documentation generation systems for R]{Existing
  documentation generation systems for \R}

%% PhG: the usual package.skeleton() is NOT a solution to mix code and
%% documentation because it does not use existing comments to fill Rd
%% files. I would be more comfortable to present it as the starting point
%% that is, the default R documentation tools...

For package documentation generation, \R's \code{package.skeleton()} function
ships with base \R\ \citep{R}. After specifying some input \R code files or
objects to use for the package, it produces some bare-bones documentation that
you must fill in using a text editor. Although \code{package.skeleton()}
is sufficient for creating small packages that are published once and
forgotten, it offers no help for packages for which Rd files are
frequently updated.

% TDH 2011-03-14 This next paragraph is offtopic, perhaps delete if
% space is required?

For automatic report generation, the mature Sweave \citep{sweave}
format, also included in the default installation of \R allows integration of \R\  code and results within \LaTeX\ documents \citep{latex}. However, the goal
of \inlinedocs\ is different. It aims for integration of Rd documentation
inside of \R\  code files, for documentation generation using \R\  code and markup
in \R\  comments.

The other existing approaches, \Rdoc\ and \Roxygen, attempt to address
this sustainability problem using Rd generation from special comments
in \R\  code \citep{rdoc,roxygen}. The documentation is thus written
closer to the code it documents, which is easier to maintain. These
packages are a step toward seamless integration of code and
documentation, but they have three major drawbacks:

\begin{enumerate}
\item They only use comments to generate documentation, ignoring the
  information already defined in the code. This is particularly
  problematic for documenting function arguments, which requires the
  repetition of the argument names in the function definition and the
  documentation. This repetition is a possible source of disagreement
  between code and documentation if both are not simultaneously
  updated.
\item The documentation for an object appears in comments above its
  definition. These comment blocks can grow to be quite large, and
  thus they tend to be far away from the relevant code.
\item Examples are defined either in comments or in supplementary \R\ 
  code files. Examples in comments are not easy to test and debug with
  the \R\  interpreter, and supplementary \R\ code files reintroduce the
  separation of code and documentation that these tools are supposed
  to eliminate.
\end{enumerate}

\subsection{Documentation using inline comments}

The \inlinedocs\ package addresses the aforementioned issues by proposing
a new syntax for inline documentation of \R\ packages. Using \inlinedocs,
one writes documentation in comments right next to the relevant code,
and examples in the \code{"ex"} attribute of the relevant object. The
resulting code is free of duplication and very easy to maintain.

%% PhG: incredibly easy to maintain appears a little too strong to me.

The remainder of the article is organized as follows. In
\autoref{syntax}, we discuss the details of the \inlinedocs\ syntax
for writing documentation in \R\  comments. In \autoref{extensible}, we
discuss the design and implementation of \inlinedocs, and detail how
the syntax can be extended. In \autoref{conclusions}, we conclude and
offer some ideas for future improvements.

\section[The inlinedocs syntax for inline documentation of R packages]{The
  \inlinedocs\ syntax for inline
  documentation of \R\ packages}
\label{syntax}

The main idea of \inlinedocs\ is to document an \R\ object using
special comments directly adjacent to its source code. Adjacent
\inlinedocs-comments are:

\begin{itemize}
\item \verb+##<<+ on the same line as the the \R-object
\item \verb+###+ on the lines directly following the \R-object
\item \verb+###+ on the line directly before the \R-object
\end{itemize}

Furthermore, \inlinedocs\ allows to put text of various documentation
sections anywhere in the function header or body by using the
\verb+##SECTION<<+ notation.

The choice of the trigger character strings is derived from the default
behaviour of the automatic indentation provided by the ``Emacs speaks
statistics'' add-on package for Emacs:
\begin{itemize}
\item \verb+###+ is automatically aligned to the left hand margin,
  providing maximum space for comment text;
\item \verb+##<<+ at line start is aligned with the start of adjacent code
  lines, so that comments using this form in the middle of a function do
  not obscure the code structure;
\item A single \verb+#+ following code on a line is automatically placed
  well to the right, which would be unduly restrictive when adding the
  comments for function arguments and other lists, so the double \verb+##+
  form was preferred.
\end{itemize}

The use of \verb+<<+ same-line comments was originally based on the Doxygen
system, where C++ function parameters may be documented by \verb+///<+ on
the same line as the parameter. The second \verb+<+ was initially added
because it felt more natural when typing double \verb+##+ to also type
double \verb+<<+. However that notation has a happy resemblance to the C++
``put'' operator, so that the \verb+##SECTION<<+ notation may be thought of
as putting the following documentation into the specified section.

The following subsections describe common usage of \inlinedocs\
comments.

\subsection{Documenting function signatures and return values}

%% PhG: in the functions arguments, I personally prefer to place the coma
%% after the previous argument, which is a more common practice witn mutiline
%% R code that is more readable if the last character clearly shows that the
%% instruction is not finished. I change this in the examples, but feel free
%% to change it back if you don't like that presentation

The following examples demonstrates the basic documentation of a function.
<<>>=
foo <- function (
  ### Adding two arguments
  first,          ##<< the first argument 
  second = 0      ##<< the second argument with a multi-line description
    ## that is possibly better located in the details section
){
  first + second 
  ### returns the sum of 
  ### first and second
}
@ 

The comments are placed within sections of the corresponding 
documentation:
\begin{itemize}
\item Comment following the line of \code{function} is the description
section.
\item For each argument an item is created in the arguments section.
\item Comments following a \code{return} statement or the last line of the body make up the
value section.
\end{itemize} 

Name, alias and title of the documentation are set to the function name. The
location of white spaces, brackets, default arguments and commas is quite flexible.

The documentation styles may be mixed - for function return value, title
and description, any \verb+###+ lines are processed first, then, in the
order in which they occur in the source, the text from any corresponding
\verb+##SECTION<<+ comments is appended.  Similar rules apply to function
arguments and the \verb+##<<+ comments.

\subsection{Documenting descriptions, links, and references}
The comments of the following example are placed in the title, details, and
seealso sections respectively.
 
<<>>=
bar <- function (
  ### Demonstrating section comments
  ##title<< bar-Function
){
  ##details<<
  ## This comment will show up in the details section.
  b <- rep(1,10)
  for (i in 2:10) {
    ##details<<
    ## The cumulative sum, here, is calculated by a loop.\cr
    ## Such comments can be placed anywhere in the code.
    b[i] <- b[i - 1] + i
  }
  b
  ### vector of cumulative sume of 1:10
  ##seealso<< \code{\link{foo}}
}
@

The \verb+##SECTION<<+ notation can be used for all documentation
sections (references, source, note, author, seealso, title, keyword, \ldots)
except for the examples section, which is handled in a special manner as
shown below. 

There may be multiple occurrences of each section type - normally
concatenated as separate paragraphs, but special processing is applied to
match the intended use of the following:
\begin{description}
\item[title] sections are concatenated into a single line;
\item[description] sections should be brief, so are concatenated into a
  single paragraph;
\item[alias] contents are split to give one alias per line of text;
\item[keyword] contents are split at white space, each generating a
  separate \verb+\keyword+ entry;
\end{description}

\subsection{Documenting list entries}
The documentation of list entries is conveniently done using \inlinedocs\ as
shown in the following example.

<<>>=
center <- function (
  ### Average of a sample
  x,              ##<< numeric vector of samples
  method = c(     ##<< method for calulating the center 
    ##describe<<
    mean = "mean",      ##<< arithmetic mean   
    median = "median"), ##<< median
    ##end<<
  ...             ##<< further arguments passed to mean or median
){
  method <- match.arg(method)
  res <- switch(method,
    mean = mean(x,...),
    median = median(x,...),
    stop("center: unknown method."))
  ##value<< a list with elements
  list(method = method,     ##<< method of calculating the average
       center = res)        ##<< the calculated average
  ##end<<
}
@

The list entries wrapped by \verb+##describe<<+ and \verb+##end<<+
lines can be documented in the same way as function arguments. This
construct can be nested. This means that a list entry can be a list
itself, whose items are described by such a block. Note that the
components of the list must have names. When nested \verb+##describe<<+
blocks are used, \verb+##end<<+ terminates the current level only; any
other \verb+##SECTION<<+ line terminates all the nested levels.

Because functions often return lists, the \verb+##value<<+ section
implicitly enables the same mechanism. 

\subsection[Provide examples using the ex attribute]{Provide
  examples using the \code{ex} attribute}
\label{sec:exattr}
The following code demonstrates the preferred method of writing
examples. It uses the \code{structure()} function to define the
example in the \code{ex} attribute of the object:
<<>>=
add2 <- structure(function (x) {
  x + 2
}, ex = function () {
  add2(11) == 13
})
@

This method for documenting examples was motivated by the desire to
express examples in \R\ code rather than in \R\ comments, and to keep
the examples close to the object definition. When examples are in \R\
code, they are easily transferred to the \R\ interpreter, and thus are
easy to debug. Furthermore, when examples are written close to the
object definition, it is easier to keep examples up to date and
informative.

% TDH 2011-03-14 this next paragraph isnt really specific to
% inlinedocs, perhaps delete or clarify? 
However the examples are provided, one significant advantage of the \R\ 
package system is that \verb+R CMD check+ will run the examples and
optionally compare the output with reference output. This allows automatic
regression testing of functions (almost) for free. Combined with the
simplicity of the \inlinedocs\ approach to generating a package, this makes
it worthwhile generating informal packages for almost any collection of
functions which might be reused over time, no matter how restricted their scope.

\subsection{Documenting classes and methods}

The \inlinedocs\ package automatically detects which functions are S3
methods, whether defined in plain \R, or using \verb+setConstructorS3+
and \verb+setMethodS3+ from the \pkg{R.oo} package \citep{Roo}. S4
class declarations using the \verb+setClass+ function are also
supported, but S4 generic methods are not yet supported. The following
example is from the source of \inlinedocs:
<<term=FALSE>>=
setClass("DocLink", # Link documentation among related functions
### The \code{DocLink} class provides the basis for hooking together
### documentation of related classes/functions/objects. The aim is that
### documentation sections missing from the child are inherited from
### the parent class.
    representation(name = "character", ##<< name of object
                   created = "character", ##<< how created
                   parent = "character", ##<< parent class or NA
                   code = "character", ##<< actual source lines
                   description = "character") ##<< preceding description block
         )
@ 

The inheritance referred to in this example is designed to avoid the
need for repetitive documentation when defining a class hierarchy. The
argument descriptions and other documentation sections default to
those defined in the parent class. At present it only functions when
all the definitions are within a single source file and this
``documentation inheritance'' is strictly linear within the file.

\subsection[package.skeleton.dx for generating Rd files]
{\code{package.skeleton.dx()} for generating Rd files}

The main function that the \inlinedocs\ package provides is
\code{package.skeleton.dx("pkgdir")}, which generates Rd
files in \code{pkgdir/man}. This operates first by running
\code{package.skeleton()} to generate blank Rd files, which are updated
using the inline documentation specified in the \R\  code. After running
\code{package.skeleton.dx()}, the package documentation will be up to
date with the code, and the package should pass \code{R CMD check} without
errors or warnings.

\section[The inlinedocs system of extensible documentation
generators]{The \inlinedocs\ system of extensible documentation
  generators}
\label{extensible}

The previous section explains how to write inline documentation
in \R\  code using the standard \inlinedocs\ syntax, then process it to
generate Rd files using \code{package.skeleton.dx()}. For most users of
\inlinedocs\ this should be sufficient for everyday use.

For users who wish to extend the syntax of \inlinedocs, here we
explain the internal organization of the \inlinedocs\ package. The two
central concepts are Parser Functions and Documentation Lists. Parser
Functions are used to extract documentation from \R\ code, which is
then stored in a Documentation List before writing Rd files.

\subsection{Documentation Lists store the structured content of Rd files}

A Documentation List is a list of lists that describes all of the
documentation to write to the Rd files. The elements of the outer list
correspond to Rd files in the package, and the elements of the inner
list correspond to tags in an Rd file. For example, consider the
following code and its corresponding Documentation List.

\begin{small}
\begin{minipage}{0.4\textwidth}
  R code\hrulefill
<<echo=FALSE>>=
cat(paste(readLines("doclist.R"), collapse = "\n")) 
@ 
\end{minipage}
\begin{minipage}{0.45\textwidth}
  Documentation List\hrulefill
<<echo=FALSE,result=TRUE>>=
dl <- extract.docs.file("doclist.R")
show <- lapply(dl, function (L) L[!names(L) %in% c("definition", "format")])
str(show)
@
\end{minipage}
\end{small}

\hrulefill

Parser Functions examine the lines of code on the left that define the
functions, and return the Documentation List of tags shown on the
right. This list describes the tags in the Rd files that will be
written for these functions. The names of the outer list specify the
Rd file, and the names of the inner list specify the Rd tag.

To store parsed documentation, another intermediate representation
that we considered instead of the Documentation List was the
\code{"Rd"} object, as described by \cite{new-r-help}. It is a
recursive structure of lists and character strings, which is similar
to the Documentation List format of \inlinedocs. However, from the
point of view of a Parser Function programmer, creating all the
attrbute tags to make a valid \code{"Rd"} object is too
cumbersome. Documentation lists allow rapid development of Parser
Functions which are straightforward to read, write, and modify.

\subsection[Structure of a Parser Function and forall/forfun]{Structure of a
  Parser Function and \code{forall()}/\code{forfun()}}

The job of a Parser Function is to return a Documentation List for a
package. To do this, it will require knowledge of what is defined in
the package, so the following arguments are supplied by \inlinedocs:
\begin{center}
\begin{tabular}{ll}
  Argument & Description \\
  \hline
  \code{code} & Character vector of all lines of \R\  code in the package.\\
  \code{env} & Environment in which the lines of code are evaluated.\\
  \code{objs} & List of all \R\  objects defined in the package.\\
  \code{docs} & Documentation List from previous Parser Functions.\\
  \code{desc} & 1-row matrix
  of DESCRIPTION metadata, as read by \code{read.dcf()}.
\end{tabular}
\end{center}

The \R\  code files in the package are concatenated into \code{code} and
then parsed into \code{objs}, and the DESCRIPTION metadata is
available as \code{desc}. These arguments allow complete flexibility
in the construction of Parser Functions that take apart the package
and extract meaningful Documentation Lists. In addition, the
\code{docs} argument allows for checking of what previous Parser
Functions have already extracted.

In principle, one could write a single monolithic Parser Function that
extracts all tags for all Rd files for the package, then returns the
entire Documentation List. However, in practice, this results in one
unwieldly Parser Function that does many things and is hard to
maintain. A simpler strategy is to write several smaller Parser
Functions, each of which produces an inner Documentation List for a
specific Rd file, such as the following:

<<>>=
title.from.firstline <- function (src, ...) {
  first <- src[1]
  if (grepl("#", first)) {
    list(title = gsub("[^#]*#\\s*(.*)", "\\1", first, perl = TRUE))
  } else list()
}
@

This function takes \code{src}, the \R\  code that defines a function,
and looks for a comment on the first line. If there is a comment,
\code{title.from.firstline()} returns the comment as the title in an
inner Documentation List. This a very simple and readable way to
define a Parser Function.

But how does this Parser Function get access to the \code{src} argument
for an individual function? We introduce the \code{forall()} and
\code{forfun()} functions, which transform an object-specific Parser
Function such as \code{title.from.firstline} to a Parser Function that
can work on an entire package. These functions examine the \code{objs}
and \code{docs} arguments, and call the object-specific Parser Function
on each object in turn. The \code{forfun()} function applies to every
function in the package, whereas the \code{forall()} function applies to
every documentation object in the package.

Thus, when using a Parser Function such as
\code{forfun(title.from.firstline)}, you can use the following
arguments in the definition of \code{title.from.firstline}, in
addition to those discussed above that are passed to every Parser
Function:
\begin{center}
\begin{tabular}{ll}
  Argument & Description \\
  \hline
  \code{o} & The \R\  object.\\
  \code{name} & The name of the object.\\
  \code{src} & The \code{"source"} attribute of the object.\\
  \code{doc} & The inner Documentation List
  already constructed for this object.
\end{tabular}
\end{center}

The \code{parsers} argument to \code{package.skeleton.dx()} allows
control of the list of Parser Functions used to create the
Documentation List for the package. The Parser Functions will be
called in sequence, and their results will be combined to form the
final Documentation List that will be used to write Rd files.

This design choice of \inlinedocs\ allows the development of modular
Parser Functions. For example, there is one Parser Function for
\verb+###+ comments, another for \verb+##<<+ comments, another for
adding the \code{author} tag using the Maintainer line of the
DESCRIPTION file, etc. Each of these Parser Functions is relatively
small and thus easy to maintain.

Furthermore, this design choice allows the
\inlinedocs\ syntax the be extended by simply writing a new Parser
Function. Currently, there are no extensions that take advantage of
this feature of \inlinedocs, but it serves to streamline development of
the internal \inlinedocs\ Parser Functions.

\section{Conclusions and future work}
\label{conclusions}

We have presented \inlinedocs, which is both a new syntax for inline
documentation of \R\ packages, and an extensible system for parsing this
syntax and generating the Rd files. It has been in development since
2009 on R-Forge \citep{rforge}, has seen several releases on CRAN, and
is now considered stable.

For quality assurance, we currently have implemented unit tests for
Documentation Lists, which assure that Parser Functions work as
described. We also have unit tests which ensure that the generated Rd
passes \code{R CMD check} without errors or warnings.

Currently, the \inlinedocs\ package relies on \verb+keep.source+ to access
the documentation associated with a function, but that mechanism appears
not to work for S4 class methods. There is already a mechanism which uses
\verb+parse+ on the source files to access S4 class definitions (via
\verb+setClass+) and S3 class and method definitions using the \verb+R.oo+
\verb+setConstructorS3+ and \verb+setMethodS3+ approach); it is intended to
extend that in order to find and process \verb+setMethod+ calls (as well as
the new \verb+setRefClass+ and \verb+$methods+ route for attaching methods
to such classes). There is a further uncertainty whether to document the
\verb+myFun+ method for \verb+myClass+ in \verb+myClass-class.Rd+ or
\verb+myFun-methods.Rd+. The standard \verb+package.skeleton+ places the
appropriate alias in both locations, and in order to avoid warnings from
\verb+R CMD check+ the author must choose and delete one of those. A
possible heuristic would be to say that if there is one definition for
\verb+myFun+ then the documentation goes into \verb+myClass-class.Rd+,
otherwise into \verb+myFun-methods.Rd+.

For the future, we would like to make use of Rd manipulation tools
such as \code{parse_Rd()}, as described by \cite{parseRd}. In
particular, it would be advantageous to have functions for converting
Documentation Lists to and from \code{"Rd"} objects. For example,
after converting an inner Documentation List to an \code{"Rd"} object,
we could use the \code{print.Rd()} function to write the Rd file. This
could be simpler than the current system of starting from the Rd files
from \code{package.skeleton()} and then doing find and
replace. Furthermore, a converter from \code{"Rd"} objects to
Documentation Lists would permit unit tests for the content of the Rd
generated by \inlinedocs.

\bibliography{refs}

\end{document}
