package.skeleton.dx <- function
### Automates more of the setup process for a new source
### package. After calling package.skeleton, it inspects the specified
### R code files to find inline documentation, which it adds to the Rd
### files. Should be called when the working directory is a
### packagename/R directory. It will overwrite files in the
### packagename/man directory.
(code_files=Sys.glob("*.R")
### character vector with the paths to the R code files, to be passed
### to package.skeleton, and also inspected for inline documentation
 ){
  desc <- read.dcf("../DESCRIPTION")
  name <- desc[,"Package"]
  docs <- list()
  for(cf in code_files){
    L <- extract.docs.file(cf)
    for(N in names(L))docs[[N]] <- L[[N]]
  }
  docs[[paste(name,"-package",sep="")]] <- list()
  print(docs)
  unlink(name,rec=TRUE)
  package.skeleton(name,code_files=code_files)
  cat("Modifying files automatically generated by package.skeleton:\n")
  for(N in names(docs))modify.Rd.file(N,name,docs)
  NEW <- file.path(name,'man')
  DEST <- file.path('..')
  file.copy(NEW,DEST,rec=TRUE)
  unlink(name,rec=TRUE)
}

modify.Rd.file <- function
### Add inline documentation from comments to an Rd file
### automatically-generated by package.skeleton
(N,
### Name of function/file to which we will add documentation
 pkg,
### Package name
 docs
### Named list of documentation in extracted comments
 ){
  cat(N,":",sep="")
  f <- paste(file.path(pkg,'man',N),".Rd",sep="")
  d <- docs[[N]]
  dlines <- readLines(f)

  ## add another backslash due to bug in package.skeleton
  u <- grep("\\usage[{]",dlines)+1
  dlines[u] <- gsub("\\\\","\\\\\\\\",dlines[u])
  
  ## cut out multiline return value comment
  ll <- grep("\\value[{]",dlines)+2
  if(length(ll))dlines <- dlines[-(ll:(ll+3))]
  
  torep <- sapply(names(d),name.to.match.string)
  for(fn in names(d)){
    cat(" ",fn,sep="")
    dlines[dlines==torep[fn]] <- gsub("\\\\","\\\\\\\\",d[[fn]])
  }
  dlines[dlines=="%%  ~~function to do ... ~~"] <- gsub("\\."," ",N)

  ## cut out a couple of sections that cause warnings
  o <- grep("Optionally",dlines)
  if(length(o))dlines <- dlines[-(o:(o+1))]
  dlines <- dlines[1:(tail(grep("\\examples[{]$",dlines),1)-1)]
  writeLines(dlines,f)
  cat("\n")
}
name.to.match.string <- function
### Convert documentation list names to character strings that should
### match the position in the Rd file to be replaced by contents of
### the doc list
(N
### argument name from documentation list
 ){
  if(N=="function")return("%%  ~~ A concise (1-5 lines) description of what the function does. ~~")
  if(N=="\\value")return("%%  ~Describe the value returned")
  paste("%%     ~~Describe \\code{",N,"} here~~",sep="")
}

extract.docs.file <- function
### Parse an R code file and extract inline documentation from
### comments around each function
(cf
### The R code file to parse.
 ){
  options(keep.source=TRUE)
  source(cf,local=TRUE)
  funs <- ls()[sapply(ls(),function(N)class(get(N)))=="function"]
  res <- sapply(funs,extract.docs.fun)
  res
}

extract.docs.fun <- function
### Given a function name, return a list describing inline
### documentation in the source of that function
(N
### The function name (already imported by source)
 ){
  fun <- get(N)
  code <- attr(fun,"source")
  clines <- grep("^#",code)
  bounds <- which(diff(clines)!=1)
  starts <- c(1,bounds+1)
  ends <- c(bounds,length(clines))
  res <- list()
  for(i in seq_along(starts)){
    start <- clines[starts[i]]
    end <- clines[ends[i]]
    lab <- if(end+1==length(code))"\\value"
    else gsub("^([^=,]*)[=,].*","\\1",gsub("^[ (]*","",code[start-1]))
    res[[lab]] <- paste(gsub("### ","",code[start:end]),collapse=" ")
  }
  res
### Named list of character strings extracted from comments. Each name
### corresponds to an argument of the function or a special keyword
### (recognized by name.to.match.string) used to place the comments in
### the Rd file.
}

