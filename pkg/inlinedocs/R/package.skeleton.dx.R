decomment <- function
### Remove comment prefix and join lines of code to form a
### documentation string.
(comments
### Character vector of prefixed comment lines.
 ){
  paste(gsub("### ","",comments),collapse=" ")
### String without prefixes or newlines.
}

package.skeleton.dx <- function
### Automates more of the setup process for a new source
### package. After inspecting the specified R code files to find
### inline documentation, it calls the standard package.skeleton
### function, which creates bare Rd files. The inline documentation is
### added to these Rd files and then these files are copied to
### ../man. Should be called when the working directory is a
### packagename/R directory. It will overwrite files in the
### packagename/man directory.
(code_files=Sys.glob("*.R")
### character vector with the paths to the R code files in the current
### working directory, to be passed to package.skeleton, and also
### inspected for inline documentation
 ){
  desc <- read.dcf("../DESCRIPTION")
  name <- desc[,"Package"]
  docs <- list()
  for(cf in code_files){
    L <- extract.docs.file(cf)
    for(N in names(L))docs[[N]] <- L[[N]]
  }
  docs[[paste(name,"-package",sep="")]] <- list()

  for(i in names(docs)){
    docs[[i]]$`\\author` <- desc[,"Maintainer"]
    docs[[i]]$`\\title` <- i
  }
  unlink(name,rec=TRUE)
  package.skeleton(name,code_files=code_files)
  cat("Modifying files automatically generated by package.skeleton:\n")
  for(N in names(docs))modify.Rd.file(N,name,docs)
  NEW <- file.path(name,'man')
  DEST <- file.path('..')
  unlink(Sys.glob(file.path("..","man","*.Rd")))
  file.copy(NEW,DEST,rec=TRUE)
  unlink(name,rec=TRUE)
}

modify.Rd.file <- function
### Add inline documentation from comments to an Rd file
### automatically-generated by package.skeleton
(N,
### Name of function/file to which we will add documentation
 pkg,
### Package name
 docs
### Named list of documentation in extracted comments
 ){
  cat(N,":",sep="")
  f <- paste(file.path(pkg,'man',N),".Rd",sep="")
  d <- docs[[N]]
  dlines <- readLines(f)

  ## cut out all comments {} interferes with regex matching
  dlines <- dlines[-grep("^[%~]",dlines)]

  ## cut out a couple of sections that cause warnings
  o <- grep("Optionally",dlines)
  if(length(o))dlines <- dlines[-(o:(o+1))]
  dlines <- dlines[1:(tail(grep("\\examples[{]$",dlines),1)-1)]

  ## Find and replace based on data in d
  txt <- paste(dlines,collapse="\n")
  for(torep in names(d)){
    cat(" ",torep,sep="")
    txt <- gsub(paste(gsub("([{}])","\\\\\\1",torep),"[{][^}]*[}]",sep=""),
                paste(torep,"{",d[[torep]],"}",sep=""),txt)
  }

  ## Fix usage
  m <- regexpr("usage[{][^}]*[}]",txt)
  utxt <- substr(txt,m,m+attr(m,"match.length"))
  ## add another backslash due to bug in package.skeleton
  substr(txt,m,m+attr(m,"match.length")) <- gsub("\\\\","\\\\\\\\",utxt)
  ## This doesn't work if there are quotes in the default values:
  ## gsub(",",paste("\n",paste(rep(" ",l=nchar(N)-1),collapse="")),utxt)
  
  cat(txt,file=f)
  cat("\n")
}

extract.docs.file <- function
### Parse an R code file and extract inline documentation from
### comments around each function.
(code.file
### The R code file to parse.
 ){
  code <- readLines(code.file)
  e <- new.env()
  old <- options(keep.source.pkgs=TRUE)
  sys.source(code.file,e)
  options(old)
  objs <- sapply(ls(e),get,e)
  extract.docs <- function(on){
    o <- objs[[on]]
    if(class(o)=="function")extract.docs.fun(o)
    ## Take the line before the first occurence of the variable
    else list(`\\description`=
              decomment(code[grep(paste("^",on,sep=""),code)[1]-1]))
  }
  res <- sapply(names(objs),extract.docs)
  res
### named list of lists. Each element is the result of a call to
### extract.docs.fun, with names corresponding to functions found in
### the R code file.
}

extract.docs.fun <- function
### Given a function name, return a list describing inline
### documentation in the source of that function.
(fun
### The function to examine.
 ){
  code <- attr(fun,"source")
  clines <- grep("^#",code)
  bounds <- which(diff(clines)!=1)
  starts <- c(1,bounds+1)
  ends <- c(bounds,length(clines))
  res <- list()
  for(i in seq_along(starts)){
    start <- clines[starts[i]]
    end <- clines[ends[i]]
    lab <- if(end+1==length(code))"\\value"
    else if(start==2)"\\description"
    else paste("\\item{",
               gsub("^([^=,]*)[=,].*","\\1",
                    gsub("^[ (]*","",code[start-1])),
               "}",sep="")
    res[[lab]] <- decomment(code[start:end])
  }
  res
### Named list of character strings extracted from comments. Each name
### corresponds to an argument of the function or a special keyword
### (recognized by name.to.match.string) used to place the comments in
### the Rd file.
}

